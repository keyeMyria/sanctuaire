// generated by jsonenums -type=Level; DO NOT EDIT

package types

import (
	"encoding/json"
	"fmt"
)

var (
	_LevelNameToValue = map[string]Level{
		"LevelDebug":   LevelDebug,
		"LevelInfo":    LevelInfo,
		"LevelSuccess": LevelSuccess,
		"LevelWarn":    LevelWarn,
		"LevelError":   LevelError,
		"LevelFatal":   LevelFatal,
	}

	_LevelValueToName = map[Level]string{
		LevelDebug:   "LevelDebug",
		LevelInfo:    "LevelInfo",
		LevelSuccess: "LevelSuccess",
		LevelWarn:    "LevelWarn",
		LevelError:   "LevelError",
		LevelFatal:   "LevelFatal",
	}
)

func init() {
	var v Level
	if _, ok := interface{}(v).(fmt.Stringer); ok {
		_LevelNameToValue = map[string]Level{
			interface{}(LevelDebug).(fmt.Stringer).String():   LevelDebug,
			interface{}(LevelInfo).(fmt.Stringer).String():    LevelInfo,
			interface{}(LevelSuccess).(fmt.Stringer).String(): LevelSuccess,
			interface{}(LevelWarn).(fmt.Stringer).String():    LevelWarn,
			interface{}(LevelError).(fmt.Stringer).String():   LevelError,
			interface{}(LevelFatal).(fmt.Stringer).String():   LevelFatal,
		}
	}
}

// MarshalJSON is generated so Level satisfies json.Marshaler.
func (r Level) MarshalJSON() ([]byte, error) {
	if s, ok := interface{}(r).(fmt.Stringer); ok {
		return json.Marshal(s.String())
	}
	s, ok := _LevelValueToName[r]
	if !ok {
		return nil, fmt.Errorf("invalid Level: %d", r)
	}
	return json.Marshal(s)
}

// UnmarshalJSON is generated so Level satisfies json.Unmarshaler.
func (r *Level) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("Level should be a string, got %s", data)
	}
	v, ok := _LevelNameToValue[s]
	if !ok {
		return fmt.Errorf("invalid Level %q", s)
	}
	*r = v
	return nil
}
